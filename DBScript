
SELECT table_name FROM all_tables WHERE owner = 'ABC';

SELECT table_name, grantee, privilege
FROM dba_tab_privs
WHERE owner = 'ABC'
  AND grantee IN ('ROLE1', 'ROLE2')
ORDER BY table_name, grantee, privilege;



SELECT t.table_name,
       p.grantee,
       p.privilege
FROM all_tables t
LEFT JOIN dba_tab_privs p
  ON t.table_name = p.table_name
  AND t.owner = p.owner
  AND p.grantee IN ('ROLE1', 'ROLE2')
WHERE t.owner = 'ABC'
ORDER BY t.table_name, p.grantee, p.privilege;

GRANT SELECT, INSERT, UPDATE, DELETE ON ABC.table_name TO ROLE1;
GRANT SELECT, INSERT, UPDATE, DELETE ON ABC.table_name TO ROLE2;


-- List all tables not in schema ABC
SELECT 'TABLE' AS object_type, owner, table_name AS object_name
FROM all_tables
WHERE owner <> 'ABC'
UNION ALL
-- List all indexes not in schema ABC
SELECT 'INDEX' AS object_type, owner, index_name AS object_name
FROM all_indexes
WHERE owner <> 'ABC'
UNION ALL
-- List all sequences not in schema ABC
SELECT 'SEQUENCE' AS object_type, sequence_owner AS owner, sequence_name AS object_name
FROM all_sequences
WHERE sequence_owner <> 'ABC'
ORDER BY object_type, owner, object_name;

-- List all tables not in schema ABC
SELECT 'TABLE' AS object_type, owner, table_name AS object_name
FROM all_tables
WHERE owner <> 'ABC'
UNION ALL
-- List all indexes not in schema ABC
SELECT 'INDEX' AS object_type, owner, index_name AS object_name
FROM all_indexes
WHERE owner <> 'ABC'
UNION ALL
-- List all sequences not in schema ABC
SELECT 'SEQUENCE' AS object_type, sequence_owner AS owner, sequence_name AS object_name
FROM all_sequences
WHERE sequence_owner <> 'ABC'
ORDER BY object_type, owner, object_name;

-- List all tables not in tablespace ABC_TABLESPACE
SELECT 'TABLE' AS object_type, owner, table_name AS object_name, tablespace_name
FROM all_tables
WHERE tablespace_name <> 'ABC_TABLESPACE'
UNION ALL
-- List all indexes not in tablespace ABC_TABLESPACE
SELECT 'INDEX' AS object_type, owner, index_name AS object_name, tablespace_name
FROM all_indexes
WHERE tablespace_name <> 'ABC_TABLESPACE'
UNION ALL
-- List all sequences not owned by schema ABC (since sequences do not reside in a specific tablespace)
SELECT 'SEQUENCE' AS object_type, sequence_owner AS owner, sequence_name AS object_name, NULL AS tablespace_name
FROM all_sequences
WHERE sequence_owner <> 'ABC'
ORDER BY object_type, owner, object_name;

-- List tables and their indexes
SELECT t.table_name, i.index_name
FROM all_tables t
LEFT JOIN all_indexes i
  ON t.table_name = i.table_name AND t.owner = i.owner
WHERE t.owner = 'YOUR_SCHEMA_NAME'
ORDER BY t.table_name, i.index_name;

-- List tables without any indexes
SELECT t.table_name
FROM all_tables t
LEFT JOIN all_indexes i
  ON t.table_name = i.table_name AND t.owner = i.owner
WHERE t.owner = 'YOUR_SCHEMA_NAME'
  AND i.index_name IS NULL;


-- List of primary keys in schema ABC
SELECT 'Primary Key' AS constraint_type, table_name, column_name
FROM all_cons_columns
WHERE owner = 'ABC'
  AND constraint_name IN (
    SELECT constraint_name
    FROM all_constraints
    WHERE constraint_type = 'P'
      AND owner = 'ABC'
  )
UNION ALL
-- List of foreign key relationships in schema ABC
SELECT 'Foreign Key' AS constraint_type, fk.table_name, fkc.column_name
FROM
  all_constraints fk
  JOIN all_cons_columns fkc ON fk.constraint_name = fkc.constraint_name AND fk.owner = fkc.owner
  JOIN all_constraints pk ON fk.r_constraint_name = pk.constraint_name
  JOIN all_cons_columns pkc ON pk.constraint_name = pkc.constraint_name AND pk.owner = pkc.owner
WHERE
  fk.constraint_type = 'R'
  AND fk.owner = 'ABC'
ORDER BY
  table_name, column_name;



SELECT t.table_name
FROM all_tables t
LEFT JOIN (
  SELECT DISTINCT table_name
  FROM all_indexes
  WHERE owner = 'ABC'
) i ON t.table_name = i.table_name
WHERE t.owner = 'ABC' AND i.table_name IS NULL
ORDER BY t.table_name;

-- List of primary keys in schema ABC
SELECT 'Primary Key' AS constraint_type, 
       pk.table_name AS primary_key_table, 
       pkc.column_name AS primary_key_column,
       '' AS foreign_key_table, -- No foreign key table for primary keys
       '' AS foreign_key_column -- No foreign key column for primary keys
FROM all_constraints pk
JOIN all_cons_columns pkc 
  ON pk.constraint_name = pkc.constraint_name AND pk.owner = pkc.owner
WHERE pk.owner = 'ABC'
  AND pk.constraint_type = 'P'

UNION ALL

-- List of foreign key relationships in schema ABC
SELECT 'Foreign Key' AS constraint_type, 
       pk.table_name AS primary_key_table, 
       pkc.column_name AS primary_key_column,
       fk.table_name AS foreign_key_table,
       fkc.column_name AS foreign_key_column
FROM all_constraints fk
JOIN all_cons_columns fkc 
  ON fk.constraint_name = fkc.constraint_name AND fk.owner = fkc.owner
JOIN all_constraints pk 
  ON fk.r_constraint_name = pk.constraint_name
JOIN all_cons_columns pkc 
  ON pk.constraint_name = pkc.constraint_name AND pk.owner = pkc.owner
WHERE fk.constraint_type = 'R'
  AND fk.owner = 'ABC'
ORDER BY primary_key_table, primary_key_column, foreign_key_table, foreign_key_column;

//

SELECT constname AS constraint_name,
       tbname AS table_name,
       reftbname AS referenced_table_name,
       fk_colnames AS foreign_key_columns,
       pk_colnames AS primary_key_columns
FROM syscat.references
WHERE tabschema = 'ABC'
ORDER BY tbname, constname;

SELECT constname AS constraint_name,
       tabname AS table_name,
       enforced
FROM syscat.checks
WHERE tabschema = 'ABC'
ORDER BY tabname, constname;

SELECT constname AS constraint_name,
       tabname AS table_name,
       type AS constraint_type,
       enforced
FROM syscat.tabconst
WHERE tabschema = 'ABC'
ORDER BY tabname, constname;

#current
SELECT 
    p.grantee, 
    p.privilege, 
    p.table_name AS sequence_name, 
    p.grantor
FROM 
    dba_tab_privs p
JOIN 
    all_sequences s ON p.table_name = s.sequence_name AND p.owner = s.sequence_owner
WHERE 
    s.sequence_owner = 'ABC'
    AND s.sequence_owner = p.owner
    AND p.table_name = s.sequence_name
ORDER BY 
    p.table_name, p.grantee;

-- Oracle Generate checksum for each row
SELECT 
    DBMS_CRYPTO.HASH(UTL_RAW.CAST_TO_RAW(col1 || col2 || col3 || ...), 2) AS row_checksum
FROM 
    target_table;

SELECT SUM(STANDARD_HASH(column_name, 'CRC32')) FROM target_table;


-- Db2 Generate checksum for each row
SELECT 
    CRC32(col1 || col2 || col3 || ...) AS row_checksum
FROM 
    source_table;

SELECT SUM(CAST(CRC32(column_name) AS BIGINT)) FROM source_table;

#

-- Check all grants on the sequence MY_SEQUENCE
SELECT grantee, privilege, grantable
FROM all_tab_privs
WHERE table_name = 'MY_SEQUENCE'
  AND owner = 'ABC';

-- Check if MY_USER has privileges on the sequence MY_SEQUENCE
SELECT grantee, privilege, grantable
FROM all_tab_privs
WHERE table_name = 'MY_SEQUENCE'
  AND owner = 'ABC'
  AND grantee = 'MY_USER';

-- Check all privileges MY_USER has
SELECT table_name, privilege
FROM all_tab_privs
WHERE grantee = 'MY_USER';
#chnage for mybatis

mybatis.config-location=classpath:mybatis-config.xml


<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
    PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <typeHandlers>
        <typeHandler handler="your.package.OracleNumListTypeHandler" javaType="java.util.List" jdbcType="ARRAY"/>
    </typeHandlers>
</configuration>

import org.apache.ibatis.type.BaseTypeHandler;
import org.apache.ibatis.type.JdbcType;
import oracle.jdbc.OracleConnection;
import oracle.sql.ARRAY;
import oracle.sql.ArrayDescriptor;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.List;

public class OracleLongArrayTypeHandler extends BaseTypeHandler<List<Long>> {

  @Override
  public void setNonNullParameter(PreparedStatement ps, int i,
      List<Long> parameter, JdbcType jdbcType) throws SQLException {
    // Convert List<Long> to a Long[]
    Long[] longArray = parameter.toArray(new Long[0]);

    // Get the OracleConnection
    OracleConnection conn = ps.getConnection().unwrap(OracleConnection.class);
    
    // Create an Oracle Array for the "NUM_LIST" type
    Array array = conn.createOracleArray("NUM_LIST", longArray);

    // Set the Array to the PreparedStatement
    ps.setArray(i, array);
    
    // Free the array after usage
    array.free();
  }

  @Override
  public List<Long> getNullableResult(ResultSet rs, String columnName) throws SQLException {
    // Handle retrieval if necessary
    return null; // Implement as needed
  }

  @Override
  public List<Long> getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
    // Handle retrieval if necessary
    return null; // Implement as needed
  }

  @Override
  public List<Long> getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
    // Handle retrieval if necessary
    return null; // Implement as needed
  }
}

 @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        
        // Register the custom TypeHandler
        org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();
        configuration.getTypeHandlerRegistry().register(List.class, JdbcType.ARRAY, OracleLongArrayTypeHandler.class);
        sqlSessionFactoryBean.setConfiguration(configuration);
        
        return sqlSessionFactoryBean.getObject();
    }
import org.apache.ibatis.type.BaseTypeHandler;
import org.apache.ibatis.type.JdbcType;
import oracle.jdbc.OracleConnection;

import java.sql.Array;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.ResultSet;
import java.sql.CallableStatement;
import java.util.List;

public class OracleLongArrayTypeHandler extends BaseTypeHandler<List<Long>> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, List<Long> parameter, JdbcType jdbcType) throws SQLException {
        OracleConnection conn = ps.getConnection().unwrap(OracleConnection.class);
        
        // Convert List<Long> to array of Long objects
        Long[] array = parameter.toArray(new Long[0]);
        
        // Create Oracle Array of type NUM_LIST
        Array oracleArray = conn.createOracleArray("NUM_LIST", array);
        
        ps.setArray(i, oracleArray);
    }

    @Override
    public List<Long> getNullableResult(ResultSet rs, String columnName) throws SQLException {
        return convertSqlArrayToList(rs.getArray(columnName));
    }

    @Override
    public List<Long> getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
        return convertSqlArrayToList(rs.getArray(columnIndex));
    }

    @Override
    public List<Long> getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
        return convertSqlArrayToList(cs.getArray(columnIndex));
    }

    private List<Long> convertSqlArrayToList(Array sqlArray) throws SQLException {
        if (sqlArray == null) {
            return null;
        }
        Long[] array = (Long[]) sqlArray.getArray();
        return List.of(array);
    }
}

-- Generate REVOKE statements for Role1 and Role2 for all users in schema ABC
SELECT 'REVOKE ' || granted_role || ' FROM ' || grantee || ';' AS revoke_statement
FROM dba_role_privs
WHERE granted_role IN ('ROLE1', 'ROLE2')
  AND grantee IN (
      SELECT username
      FROM dba_users
      WHERE default_tablespace = 'ABC'  -- Adjust this condition based on how you identify users in schema ABC
  );
BEGIN
    FOR revoke_stmt IN (
        SELECT 'REVOKE ' || granted_role || ' FROM ' || grantee || ';' AS revoke_statement
        FROM dba_role_privs
        WHERE granted_role IN ('ROLE1', 'ROLE2')
          AND grantee IN (
              SELECT username
              FROM dba_users
              WHERE default_tablespace = 'ABC'  -- Adjust this condition based on how you identify users in schema ABC
          )
    ) LOOP
        EXECUTE IMMEDIATE revoke_stmt.revoke_statement;
    END LOOP;
END;
/
SELECT grantee, granted_role
FROM dba_role_privs
WHERE granted_role IN ('ROLE1', 'ROLE2')
  AND grantee IN (
      SELECT username
      FROM dba_users
      WHERE default_tablespace = 'ABC'
  );

-- Check system privileges for ROLE1
SELECT * 
FROM dba_sys_privs 
WHERE grantee = 'ROLE1';

-- Check object privileges for ROLE1
SELECT * 
FROM dba_tab_privs 
WHERE grantee = 'ROLE1';

-- Check if ROLE1 has other roles granted to it
SELECT * 
FROM dba_role_privs 
WHERE grantee = 'ROLE1';

-- Granting CREATE SESSION to USER1
GRANT CREATE SESSION TO USER1;

-- Granting ROLE1 back to USER1
GRANT ROLE1 TO USER1;

Compress on DB2 
BEGIN
  FOR v_row AS
    SELECT TABNAME 
    FROM SYSCAT.TABLES 
    WHERE TABSCHEMA = 'ABC'
  DO
    EXECUTE IMMEDIATE 'ALTER TABLE ABC.' || v_row.TABNAME || ' COMPRESS YES';
  END FOR;
END
ALTER TABLE ABC.table_name COMPRESS YES;
REORG TABLE ABC.table_name;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Properties;

public class OracleProxyConnection {
    public static Connection getProxyConnection() throws SQLException {
        // Connect as ABC user initially
        Connection connection = DriverManager.getConnection("jdbc:oracle:thin:@//hostname:port/service_name");

        // Set up the properties for proxy
        Properties proxyProps = new Properties();
        proxyProps.put(oracle.jdbc.OracleConnection.PROXY_USER_NAME, "USER1");

        // Enable proxy 
        ((oracle.jdbc.OracleConnection) connection).openProxySession(oracle.jdbc.OracleConnection.PROXYTYPE_USER_NAME, proxyProps);

        return connection;
    }
}
#Identifying Locked Objects:
SELECT
    s.sid,
    s.serial#,
    s.username,
    s.osuser,
    l.type,
    o.object_name,
    o.object_type
FROM
    v$locked_object l
    JOIN dba_objects o ON l.object_id = o.object_id
    JOIN v$session s ON l.session_id = s.sid;
#Session lock 
SELECT
    s1.username || '@' || s1.machine || ' (SID=' || s1.sid || ')' AS blocking_session,
    s2.username || '@' || s2.machine || ' (SID=' || s2.sid || ')' AS waiting_session,
    o.object_name AS locked_object,
    s2.event,
    s2.wait_time,
    s2.seconds_in_wait
FROM
    v$lock l1
    JOIN v$session s1 ON l1.sid = s1.sid
    JOIN v$lock l2 ON l1.id1 = l2.id1 AND l1.id2 = l2.id2
    JOIN v$session s2 ON l2.sid = s2.sid
    JOIN dba_objects o ON l1.id1 = o.object_id
WHERE
    l1.block = 1 AND l2.request > 0;

#ALTER SYSTEM KILL SESSION 'sid,serial#' IMMEDIATE;


1. Check Grants for All Tables/Stored Procedures in Schema ABC (Oracle)
To list the grants on tables and stored procedures in the ABC schema, you can use the following queries:
a) Grants on Tables:

SELECT table_name, grantee, privilege
FROM dba_tab_privs
WHERE owner = 'ABC';
b) Grants on Stored Procedures (Packages, Procedures, Functions):

SELECT object_name, grantee, privilege
FROM dba_tab_privs
WHERE owner = 'ABC'
  AND object_type IN ('PROCEDURE', 'FUNCTION', 'PACKAGE');
2. Compare Constraints for All Tables in Schema ABC Between DB2 and Oracle
You'll need to extract the constraints from both DB2 and Oracle, and then compare them.
a) List Constraints in DB2:
To list constraints in DB2 for schema ABC, you can run the following:

SELECT constname AS constraint_name,
       tabname AS table_name,
       type AS constraint_type
FROM syscat.tabconst
WHERE tabschema = 'ABC';
b) List Constraints in Oracle:
For Oracle, the following query can be used:

SELECT constraint_name, table_name, constraint_type
FROM dba_constraints
WHERE owner = 'ABC';

3. Compare Configuration Parameters Between DB2 and Oracle
Configuration parameters affect performance, and it's essential to compare key parameters in both DBMSs.
a) Extract Configuration Parameters in DB2:
For DB2, run the following command to get the database configuration:

GET DATABASE CONFIGURATION FOR your_db_name SHOW DETAIL;
To extract specific values such as session count, cache, and others:

SELECT * FROM sysibmadm.dbcfg WHERE name IN ('MAX_CONNECTIONS', 'PACKAGE_CACHE_SIZE');
b) Extract Configuration Parameters in Oracle:
For Oracle, use the following query to get the session count, cache size, and other key parameters:

SELECT name, value
FROM v$parameter
WHERE name IN ('sessions', 'db_cache_size', 'pga_aggregate_target', 'sga_target');
c) Compare Configuration Parameters:
Again, export the results from DB2 and Oracle, and compare the key parameters. Consider matching the values that are important for performance tuning, such as connection limits, cache sizes, and memory allocation.
4. Compare All Sequences in Schema ABC Between DB2 and Oracle
To ensure the sequences in both databases are in sync, you can compare their current values and other properties.
a) Get Sequences in DB2:
To list all sequences in DB2, use the following query:
SELECT seqname AS sequence_name, 
       seqschema AS schema_name, 
       lastusedval AS current_value 
FROM syscat.sequences 
WHERE seqschema = 'ABC';
b) Get Sequences in Oracle:
To list all sequences in Oracle, run this query:

SELECT sequence_name, 
       last_number AS current_value 
FROM dba_sequences 
WHERE sequence_owner = 'ABC';
c) Compare Sequences:
You can manually compare the current values and properties of the sequences or automate the process using a script to extract, match, and report discrepancies.
 
Summary of Steps:
1.	Grants: Check grants on tables and stored procedures in Oracle using dba_tab_privs.
2.	Constraints: Extract constraints from both DB2 and Oracle and compare.
3.	Configuration Parameters: Extract DB2 and Oracle configurations and compare performance-related parameters like session count and cache size.
4.	Sequences: Extract sequence details from both databases and compare the current values.



BEGIN
    FOR tbl IN (
        SELECT table_name 
        FROM dba_tables 
        WHERE owner = 'ABC'
    ) LOOP
        EXECUTE IMMEDIATE 'REVOKE INSERT, UPDATE, DELETE ON ABC.' || tbl.table_name || ' FROM ROLE2';
    END LOOP;
END;
/

